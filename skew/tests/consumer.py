import datetime
import logging
import threading
import time
import unittest

from skew.backends.dummy import DummyQueue, DummyDataStore
from skew.decorators import queue_command
from skew.exceptions import QueueException
from skew.queue import Invoker, QueueCommand, PeriodicQueueCommand
from skew.registry import registry
from skew.bin.config import BaseConfiguration
from skew.bin.skew_consumer import load_config, Consumer, IterableQueue


# store some global state
state = {}

# create a queue, result store and invoker for testing
test_queue = DummyQueue('test-queue')
test_result_store = DummyDataStore('test-queue')
test_invoker = Invoker(test_queue, test_result_store)

# create a dummy config for passing to the consumer
class DummyConfiguration(BaseConfiguration):
    QUEUE = test_queue
    RESULT_STORE = test_result_store
    THREADS = 2

@queue_command(test_invoker)
def modify_state(k, v):
    state[k] = v
    return v

@queue_command(test_invoker)
def blow_up():
    raise Exception('blowed up')


# create a log handler that will track messages generated by the consumer
class TestLogHandler(logging.Handler):
    def __init__(self, *args, **kwargs):
        self.messages = []
        logging.Handler.__init__(self, *args, **kwargs)
        
    def emit(self, record):
        self.messages.append(record.getMessage())


class SkewConsumerTestCase(unittest.TestCase):
    def setUp(self):
        global state
        state = {}
        
        self.orig_sleep = time.sleep
        time.sleep = lambda x: None
        
        self.consumer = Consumer(test_invoker, DummyConfiguration)
        self.handler = TestLogHandler()
        self.consumer.logger.addHandler(self.handler)
    
    def tearDown(self):
        self.consumer.shutdown()
        self.consumer.logger.removeHandler(self.handler)
        time.sleep = self.orig_sleep
    
    def test_consumer_loader(self):
        config = load_config('skew.tests.config.Config')
        self.assertTrue(isinstance(config.QUEUE, DummyQueue))
        self.assertEqual(config.QUEUE.name, 'test-queue')
    
    def spawn(self, func, *args, **kwargs):
        t = threading.Thread(target=func, args=args, kwargs=kwargs)
        t.start()
        return t
    
    def test_iterable_queue(self):
        store = []
        q = IterableQueue()
        
        def do_queue(queue, result):
            for message in queue:
                result.append(message)
        
        t = self.spawn(do_queue, q, store)
        q.put(1)
        q.put(2)
        q.put(StopIteration)
        
        t.join()
        self.assertFalse(t.is_alive())
        self.assertEqual(store, [1, 2])
    
    def test_message_processing(self):
        self.consumer.start_message_receiver()
        self.consumer.start_worker_pool()
        
        self.assertFalse('k' in state)
        
        res = modify_state('k', 'v')
        res.get(blocking=True)
        
        self.assertTrue('k' in state)
        self.assertEqual(res.get(), 'v')
    
    def test_worker(self):
        res = modify_state('x', 'y')
        
        cmd = test_invoker.dequeue()
        self.assertEqual(res.get(), None)
        
        # we will be calling release() after finishing work
        self.consumer._pool.acquire()
        self.consumer.worker(cmd)
        
        self.assertTrue('x' in state)
        self.assertEqual(res.get(), 'y')
    
    def test_worker_exception(self):
        res = blow_up()
        cmd = test_invoker.dequeue()
        
        self.consumer._pool.acquire()
        self.consumer.worker(cmd)
        
        self.assertEqual(self.handler.messages, [
            'unhandled exception in worker thread',
        ])
    
    def test_pooling(self):
        # simulate acquiring two worker threads
        self.consumer._pool.acquire()
        self.consumer._pool.acquire()
        
        res = modify_state('x', 'y')
        
        # dequeue a *single* message 
        pt = self.spawn(self.consumer.check_message)
        
        # work on any messages generated by the processor thread
        st = self.spawn(self.consumer.worker_pool)
        
        # our result is not available since all workers are blocked
        self.assertEqual(res.get(), None)
        self.assertFalse(self.consumer._pool.acquire(blocking=False))
        
        # our processor is waiting
        self.assertTrue(pt.is_alive())
        self.assertEqual(self.consumer._queue.qsize(), 0)
        
        # release a worker
        self.consumer._pool.release()
        
        # we can get and block now, but will set a timeout of 3 to indicate that
        # something is wrong
        self.assertEqual(res.get(blocking=True, timeout=3), 'y')
        
        # this is done
        pt.join()
